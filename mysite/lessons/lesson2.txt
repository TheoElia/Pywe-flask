Python is a <b>high-level, Interpreted, Interactive and object-oriented </b> scripting language. Python was designed to be highly readable adn uses
English Keywords frequently. It has fewer syntatical constructions than other languages (This means that you need few lines of
code achieve just what other languages will use many lines of codes for).
You might have some words in the above Introduction difficult especially if you do not have any programming experience or
are a self taught programmer like myself.
So let's interpret some of them:
    <ul>
    <li><big>Python is Interpreted:</big> This means that it is proccessed at runtime (while the pprogram is runnning) by the interpreter and do not
        need to compile your program before excuting it. This is similar to PERL and PHP.
    </li>
    <li><big>Python is Interactive:</big> This means that you can actually sit at a Python prompt and interact with the interpreter by
    writing your programs as commands and getting immediate feedback.</li>
    <li><big>Python is Object-Oriented:</big> This means that Python supports Object_oriented style or teechnique of programming that encapsulates (hides coding data) within
    objects.</li>
    <li><big>Python is for Beginners:</big>Python is a great language for the beginner programmer and supports a wide range of applications - from
    simple text and mathematical data processing to WWW browsers and games.</li>
</ul>
<h4>What can you use Python for?</h4>
I get this question most often than not from people who visit this site or get to know that I handle Python tutorials. Basically,
I will tell you about what I have used Python for and then I may add what other's have also used Python for.
<ul>
    <li><b>Text and general data processing:</b> Python is really good at text processing and data manipulation. Modules (extensions mostly written by
    other Python developers) are available to make your work easier, I have used Python to read webpages and extracted what I wanted.</li>
    <li><b>Mathematical data processing:</b> I began Python with Data Science and I have not found any better programming language at this.
    Python is powerful for mathematical calculations and data presentations and again, Modules like Numpy, Scipy, Matplotlib, Pandas, among others
    come in handy if you want to do calculations and also present beautiful plotted data.</li>
    <li><b>Web Scripting:</b> Python can be used as a web scripting language. When web programming, you need to store user data and interact with
    users, and Python is just great at this, with packages like Flask, Django, ..., you can successfully build your own web application
    using few lines off codes. And yeah, this site used Python as the scripting language.</li>
    <li><b>On my Android device</b>, I use Qpython which is a great Python programming app that you can use to quickly interact with the Python interpreter and
    try out some of the new things you learn but beside that, Python provides a scripting layer for android that can be used
    to control your android device.
    Sitting on my android device is a program I call my personal assistant and it was written using python, this assistant can make calls,
    send emails, reply messages, give weather reports, it can also have a chat with you in case you are bored.</li>
    <b>Is Python not a great language?</b>
    <li>Python has also been used by the big guys to achieve a lot more than the personal ones I told you about, Google uses Python
    so maybe if you learnt Python and became really advanced, you could be employed there,or somewhere else. Do not hesitate to Google how far ypu can go with Python</li>
    <li><b>Artificial Intelligence:</b> Since Python has great processing ability with data, it has always been a great language for the
    implementation of Artificial Intelligence and Machine learning.</li>
    Those are just a few of the possibilities with Python. You can however creatively use it in your own way to achieve what you want because Python allows for
    even C extensions.
</ul>
<h4>History of Python</h4>
Python was developed by Guido van Rossum in the late eighties and early nineties at the National Research Institute for Mathematics and Computer Science in the Netherlands.
Python is derived from many other languages, including ABC, Modula-3, C, C++, Algol-68, SmallTalk, and Unix shell and other scripting languages.
Python is copyrighted. Like Perl, Python source code is now available under the GNU General Public License (GPL).
Python is now maintained by a core development team at the institute, although Guido van Rossum still holds a vital role in directing its progress.
<h4>Python Features</h4>
<b>Python's feature highlights include:</b>
<ul>
<li>Easy-to-learn: Python has relatively few keywords, simple structure, and a clearly defined syntax.
    This allows the student to pick up the language in a relatively short period of time.</li>
    <li>Easy-to-read: Python code is much more clearly defined and visible to the eyes.</li>
    <li>Easy-to-maintain: Python's success is that its source code is fairly easy-to-maintain.</li>
    <li>A broad standard library: One of Python's greatest strengths is the bulk of the library is very portable and cross-platform compatible on UNIX, Windows and Macintosh.</li>
<li>Interactive Mode: Support for an interactive mode in which you can enter results from a terminal right to the language,
    allowing interactive testing and debugging of snippets of code.</li>
    <li>Portable: Python can run on a wide variety of hardware platforms and has the same interface on all platforms.</li>
    <li>Extendable: You can add low-level modules to the Python interpreter. These modules enable programmers to add to or customize their tools to be more efficient.</li>
    <li>Databases: Python provides interfaces to all major commercial databases.</li>
<li>GUI Programming: Python supports GUI applications that can be created and ported to many system calls,
    libraries and windows systems, such as Windows MFC, Macintosh and the X Window system of Unix.</li>
    <li>Scalable: Python provides a better structure and support for large programs than shell scripting.</li>

</ul>
<b>Apart from the above-mentioned features, Python has a big list of good features, few are listed below:</b>
<ul>
    <li>Support for functional and structured programming methods as well as OOP.</li>
    <li>It can be used as a scripting language or can be compiled to byte-code for building large applications.</li>
    <li>Very high-level dynamic data types and supports dynamic type checking.</li>
    <li>Supports automatic garbage collection.</li>
    <li>It can be easily integrated with C, C++, COM, ActiveX, CORBA and Java.</li>
</ul>






##EFFIE PLEASE I HAVE DONE THE VARIABLE TYPES
Python Variable Types
Variables are nothing but reserved memory locations to store values. This means that when you create a variable you reserve some space in memory.

Based on the data type of a variable, the interpreter allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals or characters in these variables.

Assigning Values to Variables:
Python variables do not have to be explicitly declared to reserve memory space. The declaration happens automatically when you assign a value to a variable. The equal sign (=) is used to assign values to variables.

The operand to the left of the = operator is the name of the variable and the operand to the right of the = operator is the value stored in the variable. For example:

#!/usr/bin/python

counter = 100          # An integer assignment
miles   = 1000.0       # A floating point
name    = "John"       # A string

print counter
print miles
print name
Here, 100, 1000.0 and "John" are the values assigned to counter, miles and name variables, respectively. While running this program, this will produce the following result:

100
1000.0
John
Multiple Assignment:
Python allows you to assign a single value to several variables simultaneously. For example:

a = b = c = 1
Here, an integer object is created with the value 1, and all three variables are assigned to the same memory location. You can also assign multiple objects to multiple variables. For example:

	a, b, c = 1, 2, "john"
Here, two integer objects with values 1 and 2 are assigned to variables a and b, and one string object with the value "john" is assigned to the variable c.

Standard Data Types:
The data stored in memory can be of many types. For example, a person's age is stored as a numeric value and his or her address is stored as alphanumeric characters. Python has various standard types that are used to define the operations possible on them and the storage method for each of them.

Python has five standard data types:

Numbers

String

List

Tuple

Dictionary

Python Numbers:
Number data types store numeric values. They are immutable data types which means that changing the value of a number data type results in a newly allocated object.

Number objects are created when you assign a value to them. For example:

var1 = 1
var2 = 10
You can also delete the reference to a number object by using the del statement. The syntax of the del statement is:

del var1[,var2[,var3[....,varN]]]]
You can delete a single object or multiple objects by using the del statement. For example:

del var
del var_a, var_b
Python supports four different numerical types:

int (signed integers)

long (long integers [can also be represented in octal and hexadecimal])

float (floating point real values)

complex (complex numbers)

Examples:
Here are some examples of numbers:

int	long	float	complex
10	51924361L	0.0	3.14j
100	-0x19323L	15.20	45.j
-786	0122L	-21.9	9.322e-36j
080	0xDEFABCECBDAECBFBAEl	32.3+e18	.876j
-0490	535633629843L	-90.	-.6545+0J
-0x260	-052318172735L	-32.54e100	3e+26J
0x69	-4721885298529L	70.2-E12	4.53e-7j
Python allows you to use a lowercase L with long, but it is recommended that you use only an uppercase L to avoid confusion with the number 1. Python displays long integers with an uppercase L.

A complex number consists of an ordered pair of real floating-point numbers denoted by a + bj, where a is the real part and b is the imaginary part of the complex number.

Python Strings:
Strings in Python are identified as a contiguous set of characters in between quotation marks. Python allows for either pairs of single or double quotes. Subsets of strings can be taken using the slice operator ( [ ] and [ : ] ) with indexes starting at 0 in the beginning of the string and working their way from -1 at the end.

The plus ( + ) sign is the string concatenation operator and the asterisk ( * ) is the repetition operator. For example:

#!/usr/bin/python

str = 'Hello World!'

print str          # Prints complete string
print str[0]       # Prints first character of the string
print str[2:5]     # Prints characters starting from 3rd to 5th
print str[2:]      # Prints string starting from 3rd character
print str * 2      # Prints string two times
print str + "TEST" # Prints concatenated string
This will produce the following result:

Hello World!
H
llo
llo World!
Hello World!Hello World!
Hello World!TEST
Python Lists:
Lists are the most versatile of Python's compound data types. A list contains items separated by commas and enclosed within square brackets ([]). To some extent, lists are similar to arrays in C. One difference between them is that all the items belonging to a list can be of different data type.

The values stored in a list can be accessed using the slice operator ( [ ] and [ : ] ) with indexes starting at 0 in the beginning of the list and working their way to end -1. The plus ( + ) sign is the list concatenation operator, and the asterisk ( * ) is the repetition operator. For example:

#!/usr/bin/python

list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
tinylist = [123, 'john']

print list          # Prints complete list
print list[0]       # Prints first element of the list
print list[1:3]     # Prints elements starting from 2nd till 3rd
print list[2:]      # Prints elements starting from 3rd element
print tinylist * 2  # Prints list two times
print list + tinylist # Prints concatenated lists
This will produce the following result:

['abcd', 786, 2.23, 'john', 70.200000000000003]
abcd
[786, 2.23]
[2.23, 'john', 70.200000000000003]
[123, 'john', 123, 'john']
['abcd', 786, 2.23, 'john', 70.200000000000003, 123, 'john']
Python Tuples:
A tuple is another sequence data type that is similar to the list. A tuple consists of a number of values separated by commas. Unlike lists, however, tuples are enclosed within parentheses.

The main differences between lists and tuples are: Lists are enclosed in brackets ( [ ] ) and their elements and size can be changed, while tuples are enclosed in parentheses ( ( ) ) and cannot be updated. Tuples can be thought of as read-only lists. For example:

#!/usr/bin/python

tuple = ( 'abcd', 786 , 2.23, 'john', 70.2  )
tinytuple = (123, 'john')

print tuple           # Prints complete list
print tuple[0]        # Prints first element of the list
print tuple[1:3]      # Prints elements starting from 2nd till 3rd
print tuple[2:]       # Prints elements starting from 3rd element
print tinytuple * 2   # Prints list two times
print tuple + tinytuple # Prints concatenated lists
This will produce the following result:

('abcd', 786, 2.23, 'john', 70.200000000000003)
abcd
(786, 2.23)
(2.23, 'john', 70.200000000000003)
(123, 'john', 123, 'john')
('abcd', 786, 2.23, 'john', 70.200000000000003, 123, 'john')
Following is invalid with tuple, because we attempted to update a tuple, which is not allowed. Similar case is possible with lists:

#!/usr/bin/python

tuple = ( 'abcd', 786 , 2.23, 'john', 70.2  )
list = [ 'abcd', 786 , 2.23, 'john', 70.2  ]
tuple[2] = 1000    # Invalid syntax with tuple
list[2] = 1000     # Valid syntax with list
Python Dictionary:
Python's dictionaries are kind of hash table type. They work like associative arrays or hashes found in Perl and consist of key-value pairs. A dictionary key can be almost any Python type, but are usually numbers or strings. Values, on the other hand, can be any arbitrary Python object.

Dictionaries are enclosed by curly braces ( { } ) and values can be assigned and accessed using square braces ( [] ). For example:

#!/usr/bin/python

dict = {}
dict['one'] = "This is one"
dict[2]     = "This is two"

tinydict = {'name': 'john','code':6734, 'dept': 'sales'}


print dict['one']       # Prints value for 'one' key
print dict[2]           # Prints value for 2 key
print tinydict          # Prints complete dictionary
print tinydict.keys()   # Prints all the keys
print tinydict.values() # Prints all the values
This will produce the following result:

This is one
This is two
{'dept': 'sales', 'code': 6734, 'name': 'john'}
['dept', 'code', 'name']
['sales', 6734, 'john']
Dictionaries have no concept of order among elements. It is incorrect to say that the elements are "out of order"; they are simply unordered.

Data Type Conversion:
Sometimes, you may need to perform conversions between the built-in types. To convert between types, you simply use the type name as a function.

There are several built-in functions to perform conversion from one data type to another. These functions return a new object representing the converted value.

Function	Description
int(x [,base])

Converts x to an integer. base specifies the base if x is a string.

long(x [,base] )

Converts x to a long integer. base specifies the base if x is a string.

float(x)

Converts x to a floating-point number.

complex(real [,imag])

Creates a complex number.

str(x)

Converts object x to a string representation.

repr(x)

Converts object x to an expression string.

eval(str)

Evaluates a string and returns an object.

tuple(s)

Converts s to a tuple.

list(s)

Converts s to a list.

set(s)

Converts s to a set.

dict(d)

Creates a dictionary. d must be a sequence of (key,value) tuples.

frozenset(s)

Converts s to a frozen set.

chr(x)

Converts an integer to a character.

unichr(x)

Converts an integer to a Unicode character.

ord(x)

Converts a single character to its integer value.

hex(x)

Converts an integer to a hexadecimal string.

oct(x)

Converts an integer to an octal string.










Python Loops
There may be a situation when you need to execute a block of code several number of times.
In general, statements are executed sequentially(From top to down):
The first statement in a function is executed first, followed by the second, and so on.
But conditioning your code can make Python behave in another way while executing the code
from top to down.

Programming languages provide various control structures that allow for more complicated execution paths.

A loop statement allows us to execute a statement or group of statements multiple times
and following is the general form of a loop statement in most of the programming languages:
fig.

Python programming language provides following types of loops to handle looping requirements.
<pre>
Loop Type	        Description

while loop	        Repeats a statement or group of statements while a given condition is true.
                    It tests the condition before executing the loop body.

for loop	        Executes a sequence of statements multiple times
                    and abbreviates the code that manages the loop variable.

nested loops	    You can use one or more loop inside
                    any another while, for or do..while loop.

Loop Control
Statements:         Loop control statements change execution from its normal sequence.
                    When execution leaves a scope, all automatic objects that were
                    created in that scope are destroyed.
</pre>
<br>
Python supports the following control statements.
<pre>
Control Statement	            Description

break                           statement	Terminates the loop statement and transfers
                                execution to the statement immediately following the loop.

continue statement	            Causes the loop to skip the remainder of its body and
                                immediately retest its condition prior to reiterating.

pass statement	                The pass statement in Python is used when a statement is
                                required syntactically but you do not want any command
                                or code to execute.
</pre>


ExceptionsExceptions
What is Exception?
An exception is an event, which occurs during the execution of a program, that disrupts the normal flow of the program's instructions. In general, when a Python script encounters a situation that it can't cope with, it raises an exception. An exception is a Python object that represents an error.

When a Python script raises an exception, it must either handle the exception immediately otherwise it would terminate and come out.

Handling an exception:
If you have some suspicious code that may raise an exception, you can defend your program by placing the suspicious code in a try: block. After the try: block, include an except: statement, followed by a block of code which handles the problem as elegantly as possible.

Syntax:
Here is simple syntax of try....except...else blocks:

try:
   You do your operations here;
   ......................
except ExceptionI:
   If there is ExceptionI, then execute this block.
except ExceptionII:
   If there is ExceptionII, then execute this block.
   ......................
else:
   If there is no exception then execute this block.
Here are few important points about the above-mentioned syntax:

A single try statement can have multiple except statements. This is useful when the try block contains statements that may throw different types of exceptions.

You can also provide a generic except clause, which handles any exception.

After the except clause(s), you can include an else-clause. The code in the else-block executes if the code in the try: block does not raise an exception.

The else-block is a good place for code that does not need the try: block's protection.

Example:
Here is simple example, which opens a file and writes the content in the file and comes out gracefully because there is no problem at all:

#!/usr/bin/python

try:
   fh = open("testfile", "w")
   fh.write("This is my test file for exception handling!!")
except IOError:
   print "Error: can\'t find file or read data"
else:
   print "Written content in the file successfully"
   fh.close()
This will produce the following result:

Written content in the file successfully
Example:
Here is one more simple example, which tries to open a file where you do not have permission to write in the file, so it raises an exception:

#!/usr/bin/python

try:
   fh = open("testfile", "r")
   fh.write("This is my test file for exception handling!!")
except IOError:
   print "Error: can\'t find file or read data"
else:
   print "Written content in the file successfully"
This will produce the following result:

Error: can't find file or read data
The except clause with no exceptions:
You can also use the except statement with no exceptions defined as follows:

try:
   You do your operations here;
   ......................
except:
   If there is any exception, then execute this block.
   ......................
else:
   If there is no exception then execute this block.
This kind of a try-except statement catches all the exceptions that occur. Using this kind of try-except statement is not considered a good programming practice though, because it catches all exceptions but does not make the programmer identify the root cause of the problem that may occur.

The except clause with multiple exceptions:
You can also use the same except statement to handle multiple exceptions as follows:

try:
   You do your operations here;
   ......................
except(Exception1[, Exception2[,...ExceptionN]]]):
   If there is any exception from the given exception list,
   then execute this block.
   ......................
else:
   If there is no exception then execute this block.
The try-finally clause:
You can use a finally: block along with a try: block. The finally block is a place to put any code that must execute, whether the try-block raised an exception or not. The syntax of the try-finally statement is this:

try:
   You do your operations here;
   ......................
   Due to any exception, this may be skipped.
finally:
   This would always be executed.
   ......................
Note that you can provide except clause(s), or a finally clause, but not both. You can not use else clause as well along with a finally clause.

Example:
#!/usr/bin/python

try:
   fh = open("testfile", "w")
   fh.write("This is my test file for exception handling!!")
finally:
   print "Error: can\'t find file or read data"
If you do not have permission to open the file in writing mode, then this will produce the following result:

Error: can't find file or read data
Same example can be written more cleanly as follows:

#!/usr/bin/python

try:
   fh = open("testfile", "w")
   try:
      fh.write("This is my test file for exception handling!!")
   finally:
      print "Going to close the file"
      fh.close()
except IOError:
   print "Error: can\'t find file or read data"
When an exception is thrown in the try block, the execution immediately passes to the finally block. After all the statements in the finally block are executed, the exception is raised again and is handled in the except statements if present in the next higher layer of the try-except statement.

Argument of an Exception:
An exception can have an argument, which is a value that gives additional information about the problem. The contents of the argument vary by exception. You capture an exception's argument by supplying a variable in the except clause as follows:

try:
   You do your operations here;
   ......................
except ExceptionType, Argument:
   You can print value of Argument here...
If you are writing the code to handle a single exception, you can have a variable follow the name of the exception in the except statement. If you are trapping multiple exceptions, you can have a variable follow the tuple of the exception.

This variable will receive the value of the exception mostly containing the cause of the exception. The variable can receive a single value or multiple values in the form of a tuple. This tuple usually contains the error string, the error number, and an error location.

Example:
Following is an example for a single exception:

#!/usr/bin/python

# Define a function here.
def temp_convert(var):
   try:
      return int(var)
   except ValueError, Argument:
      print "The argument does not contain numbers\n", Argument

# Call above function here.
temp_convert("xyz");
This would produce the following result:

The argument does not contain numbers
invalid literal for int() with base 10: 'xyz'
Raising an exceptions:
You can raise exceptions in several ways by using the raise statement. The general syntax for the raise statement.

Syntax:
raise [Exception [, args [, traceback]]]
Here, Exception is the type of exception (for example, NameError) and argument is a value for the exception argument. The argument is optional; if not supplied, the exception argument is None.

The final argument, traceback, is also optional (and rarely used in practice), and if present, is the traceback object used for the exception.

Example:
An exception can be a string, a class or an object. Most of the exceptions that the Python core raises are classes, with an argument that is an instance of the class. Defining new exceptions is quite easy and can be done as follows:

def functionName( level ):
   if level < 1:
      raise "Invalid level!", level
      # The code below to this would not be executed
      # if we raise the exception
Note: In order to catch an exception, an "except" clause must refer to the same exception thrown either class object or simple string. For example, to capture above exception, we must write our except clause as follows:

try:
   Business Logic here...
except "Invalid level!":
   Exception handling here...
else:
   Rest of the code here...
User-Defined Exceptions:
Python also allows you to create your own exceptions by deriving classes from the standard built-in exceptions.

Here is an example related to RuntimeError. Here, a class is created that is subclassed from RuntimeError. This is useful when you need to display more specific information when an exception is caught.

In the try block, the user-defined exception is raised and caught in the except block. The variable e is used to create an instance of the class Networkerror.

class Networkerror(RuntimeError):
   def __init__(self, arg):
      self.args = arg
So once you defined above class, you can raise your exception as follows:

try:
   raise Networkerror("Bad hostname")
except Networkerror,e:
   print e.args


FUNCTIONS
Pass by reference vs value
All parameters (arguments) in the Python language are passed by reference. It means if you change what a parameter refers to within a function, the change also reflects back in the calling function. For example:

#!/usr/bin/python

# Function definition is here
def changeme( mylist ):
   "This changes a passed list into this function"
   mylist.append([1,2,3,4]);
   print "Values inside the function: ", mylist
   return

# Now you can call changeme function
mylist = [10,20,30];
changeme( mylist );
print "Values outside the function: ", mylist
Here, we are maintaining reference of the passed object and appending values in the same object. So, this would produce the following result:

Values inside the function:  [10, 20, 30, [1, 2, 3, 4]]
Values outside the function:  [10, 20, 30, [1, 2, 3, 4]]
There is one more example where argument is being passed by reference and the reference is being overwritten inside the called function.

#!/usr/bin/python

# Function definition is here
def changeme( mylist ):
   "This changes a passed list into this function"
   mylist = [1,2,3,4]; # This would assig new reference in mylist
   print "Values inside the function: ", mylist
   return

# Now you can call changeme function
mylist = [10,20,30];
changeme( mylist );
print "Values outside the function: ", mylist
The parameter mylist is local to the function changeme. Changing mylist within the function does not affect mylist. The function accomplishes nothing and finally this would produce the following result:

Values inside the function:  [1, 2, 3, 4]
Values outside the function:  [10, 20, 30]
Function Arguments:
You can call a function by using the following types of formal arguments:

Required arguments

Keyword arguments

Default arguments

Variable-length arguments

Required arguments:
Required arguments are the arguments passed to a function in correct positional order. Here, the number of arguments in the function call should match exactly with the function definition.

To call the function printme(), you definitely need to pass one argument, otherwise it would give a syntax error as follows:

#!/usr/bin/python

# Function definition is here
def printme( str ):
   "This prints a passed string into this function"
   print str;
   return;

# Now you can call printme function
printme();
When the above code is executed, it produces the following result:

Traceback (most recent call last):
  File "test.py", line 11, in <module>
    printme();
TypeError: printme() takes exactly 1 argument (0 given)
Keyword arguments:
Keyword arguments are related to the function calls. When you use keyword arguments in a function call, the caller identifies the arguments by the parameter name.

This allows you to skip arguments or place them out of order because the Python interpreter is able to use the keywords provided to match the values with parameters. You can also make keyword calls to the printme() function in the following ways:

#!/usr/bin/python

# Function definition is here
def printme( str ):
   "This prints a passed string into this function"
   print str;
   return;

# Now you can call printme function
printme( str = "My string");
When the above code is executed, it produces the following result:

My string
Following example gives more clear picture. Note, here order of the parameter does not matter.

#!/usr/bin/python

# Function definition is here
def printinfo( name, age ):
   "This prints a passed info into this function"
   print "Name: ", name;
   print "Age ", age;
   return;

# Now you can call printinfo function
printinfo( age=50, name="miki" );
When the above code is executed, it produces the following result:

Name:  miki
Age  50
Default arguments:
A default argument is an argument that assumes a default value if a value is not provided in the function call for that argument. Following example gives an idea on default arguments, it would print default age if it is not passed:

#!/usr/bin/python

# Function definition is here
def printinfo( name, age = 35 ):
   "This prints a passed info into this function"
   print "Name: ", name;
   print "Age ", age;
   return;

# Now you can call printinfo function
printinfo( age=50, name="miki" );
printinfo( name="miki" );
When the above code is executed, it produces the following result:

Name:  miki
Age  50
Name:  miki
Age  35
Variable-length arguments:
You may need to process a function for more arguments than you specified while defining the function. These arguments are called variable-length arguments and are not named in the function definition, unlike required and default arguments.

The general syntax for a function with non-keyword variable arguments is this:

def functionname([formal_args,] *var_args_tuple ):
   "function_docstring"
   function_suite
   return [expression]
An asterisk (*) is placed before the variable name that will hold the values of all nonkeyword variable arguments. This tuple remains empty if no additional arguments are specified during the function call. Following is a simple example:

#!/usr/bin/python

# Function definition is here
def printinfo( arg1, *vartuple ):
   "This prints a variable passed arguments"
   print "Output is: "
   print arg1
   for var in vartuple:
      print var
   return;

# Now you can call printinfo function
printinfo( 10 );
printinfo( 70, 60, 50 );
When the above code is executed, it produces the following result:

Output is:
10
Output is:
70
60
50
The Anonymous Functions:
You can use the lambda keyword to create small anonymous functions. These functions are called anonymous because they are not declared in the standard manner by using the def keyword.

Lambda forms can take any number of arguments but return just one value in the form of an expression. They cannot contain commands or multiple expressions.

An anonymous function cannot be a direct call to print because lambda requires an expression.

Lambda functions have their own local namespace and cannot access variables other than those in their parameter list and those in the global namespace.

Although it appears that lambda's are a one-line version of a function, they are not equivalent to inline statements in C or C++, whose purpose is by passing function stack allocation during invocation for performance reasons.

Syntax:
The syntax of lambda functions contains only a single statement, which is as follows:

lambda [arg1 [,arg2,.....argn]]:expression
Following is the example to show how lambda form of function works:

#!/usr/bin/python

# Function definition is here
sum = lambda arg1, arg2: arg1 + arg2;



# Now you can call sum as a function
print "Value of total : ", sum( 10, 20 )
print "Value of total : ", sum( 20, 20 )
When the above code is executed, it produces the following result:

Value of total :  30
Value of total :  40
The return Statement:
The statement return [expression] exits a function, optionally passing back an expression to the caller. A return statement with no arguments is the same as return None.

All the above examples are not returning any value, but if you like you can return a value from a function as follows:

#!/usr/bin/python

# Function definition is here
def sum( arg1, arg2 ):
   # Add both the parameters and return them."
   total = arg1 + arg2
   print "Inside the function : ", total
   return total;

# Now you can call sum function
total = sum( 10, 20 );
print "Outside the function : ", total
When the above code is executed, it produces the following result:

Inside the function :  30
Outside the function :  30
Scope of Variables:
All variables in a program may not be accessible at all locations in that program. This depends on where you have declared a variable.

The scope of a variable determines the portion of the program where you can access a particular identifier. There are two basic scopes of variables in Python:

Global variables

Local variables

Global vs. Local variables:
Variables that are defined inside a function body have a local scope, and those defined outside have a global scope.

This means that local variables can be accessed only inside the function in which they are declared, whereas global variables can be accessed throughout the program body by all functions. When you call a function, the variables declared inside it are brought into scope. Following is a simple example:

#!/usr/bin/python

total = 0; # This is global variable.
# Function definition is here
def sum( arg1, arg2 ):
   # Add both the parameters and return them."
   total = arg1 + arg2; # Here total is local variable.
   print "Inside the function local total : ", total
   return total;

# Now you can call sum function
sum( 10, 20 );
print "Outside the function global total : ", total
When the above code is executed, it produces the following result:

Inside the function local total :  30
Outside the function global total :  0



LISTS

Python's list is another datatype that can be used to keep other basic datatypes
in a fairly organised manner. This is because members of a list
are given position numbers by the Python interpreter and therefore
can be accessed using their positions called indexes. A list is therefore a squence.

To define a python list:
listname = [first_member,second_member,...]

These members can be any of the following datatypes:
<pre>
Boolean
Number
String
List
Tuple
Dictionary
</pre>
<br>

<h4>List Indexing<h4>

Python assigns integers to the position of the members in the list.
The first_member gets the index 0, the second_member gets the
index 1 and so on Python adds 1 to the previous index to get the index
of the current member.
Since a list can contain a lot of members at once, the last
member is referenced -1 to make it easier to access.


Lists are quite interesting and can be used to achieve a lot of things.
A list can contain any data type and even itself, a list is like a universal set that harbours subsets.

*Indexing Vs. Slicing Lists*

When you create a list in python, python gives a position number to each item in the list depending on
where it appears in the list, the numbering is done
from 0 to the last item (n-1), where n is the number if items in the list.
So, if there are 10 items in a list, the first item will take position(index) 0 and the last item will take (10-1) = 9.

You can therefore request Python to give you a particular item from the list by specifying it's index to Python - indexing

You can also ask Python to give you items from a certain point to a certain point,
you can even specify if Python should jump over particular ones, this is called list slicing.


<h4>The Program</h4>
<pre>
My_list = ['hello', 2,3.6,True]

#Let's call print
print(My_list)

#Now let's specify some index
print(My_list[3])

#This should print the
#fourth item in the
#list which is at index 3.

#Now let's slice

print(My_list[0:3])

#This should print from the first
#item to the third item,
#leaving out the one at
#index 3
</pre>




When you want Python to print from the beginning of the list, you don't need to specify the 0, just do this list_name [ : end index here].

If you want Python to print out every member of the list but at a certain step, then do this:
list_name[ : :step]

If your step was 2, then Python will print the first item and jump to the third and jump to the fifth,
that's a smart way print out odd number is your list is made of counting numbers.

You can simply ask for a reverse list by making your step -1,
this will tell Pytjon to print the last item first and go backwards.

Like this:

<code>list_name[ : : -1]</code>


Python should print out a reverse list.

<div style="border: solid steelblue 2px;>
<h5>Try it Out</h5>
Create a list of counting numbers from 0 to 21, extract a reverse of even numbers from it.
Python should print out a reverse list.
</div>




<h4>Updating Lists</h4>
You can update single or multiple elements of lists by giving the slice on
the left-hand side of the assignment operator, and you can add to elements
in a list with the append() method. Following is a simple example:

<pre>
list = ['physics', 'chemistry', 1997, 2000];

print ("Value available at index 2 : ",list[2])

list[2] = 2001
print ("New value available at index 2 : ",list[2])
</pre>

When the above code is executed, it produces the following result:
<pre>
Value available at index 2 : 1997
New value available at index 2 : 2001
</pre>

<h4>Delete List Elements</h4>
To remove a list element, you can use either the del statement if you know exactly which element(s)
you are deleting or the remove() method if you do not know. Following is a simple example:


<pre>list1 = ['physics', 'chemistry', 1997, 2000];

>>print (list1)
>>del list1[2]
print ("After deleting value at index 2 : ",list1;)
</pre>
When the above code is executed, it produces following result:
<pre>
['physics', 'chemistry', 1997, 2000]
After deleting value at index 2 :
['physics', 'chemistry', 2000]
</pre>
<br>

<h4>Basic List Operations</h4>
Lists respond to the + and * operators much like strings; they mean concatenation
and repetition here too, except that the result is a new list, not a string.

In fact, lists respond to all of the general sequence operations we used on strings in the Strings section.
<br>
<pre>
Python Expression	               Results	                Description
len([1, 2, 3])	                       3                	Length
[1, 2, 3] + [4, 5, 6]	        [1, 2, 3, 4, 5, 6]	        Concatenation
['Hi!'] * 4	                ['Hi!', 'Hi!', 'Hi!', 'Hi!']	Repetition
3 in [1, 2, 3]	                       True	                Membership
for x in [1, 2, 3]: print x,	       1 2 3	            Iteration
</pre>
<br>
<h4>Indexing, Slicing, and Matrixes</h4>
Because lists are sequences, indexing and slicing work the same way for lists as they do for strings.

Assuming following input:
<br>
<pre>
L = ['spam', 'Spam', 'SPAM!']


Python Expression       	Results         	Description

L[2]                        'SPAM!'         	Offsets start at zero

L[-2]	                    'Spam'	            Negative: count from the right

L[1:]	                ['Spam', 'SPAM!']	    Slicing fetches sections

</pre>
<br>
<h4>Built-in List Functions & Methods</h4>

Python includes the following list functions:
<br>
<pre>
SN	Function with Description

1	cmp(list1, list2)
Compares elements of both lists.

2	len(list)
Gives the total length of the list.

3	max(list)
Returns item from the list with max value.

4	min(list)
Returns item from the list with min value.

5	list(seq)
Converts a tuple into list.
Python includes following list methods

SN	Methods with Description
1	list.append(obj)
Appends object obj to list

2	list.count(obj)
Returns count of how many times obj occurs in list

3	list.extend(seq)
Appends the contents of seq to list

4	list.index(obj)
Returns the lowest index in list that obj appears

5	list.insert(index, obj)
Inserts object obj into list at offset index

6	list.pop(obj=list[-1])
Removes and returns last object or obj from list

7	list.remove(obj)
Removes object obj from list

8	list.reverse()
Reverses objects of list in place

9	list.sort([func])
Sorts objects of list, use compare func if given
</pre>



A dictionary is mutable and is another container type that can store any number of Python objects, including other container types. Dictionaries consist of pairs (called items) of keys and their corresponding values.

Python dictionaries are also known as associative arrays or hash tables. The general syntax of a dictionary is as follows:

dict = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}
You can create dictionary in the following way as well:

dict1 = { 'abc': 456 };
dict2 = { 'abc': 123, 98.6: 37 };
Each key is separated from its value by a colon (:), the items are separated by commas, and the whole thing is enclosed in curly braces. An empty dictionary without any items is written with just two curly braces, like this: {}.

Keys are unique within a dictionary while values may not be. The values of a dictionary can be of any type, but the keys must be of an immutable data type such as strings, numbers, or tuples.

Accessing Values in Dictionary:
To access dictionary elements, you can use the familiar square brackets along with the key to obtain its value. Following is a simple example:

#!/usr/bin/python

dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'};

print "dict['Name']: ", dict['Name'];
print "dict['Age']: ", dict['Age'];
When the above code is executed, it produces the following result:

dict['Name']:  Zara
dict['Age']:  7
If we attempt to access a data item with a key, which is not part of the dictionary, we get an error as follows:

#!/usr/bin/python

dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'};

print "dict['Alice']: ", dict['Alice'];
When the above code is executed, it produces the following result:

dict['Zara']:
Traceback (most recent call last):
  File "test.py", line 4, in <module>
    print "dict['Alice']: ", dict['Alice'];
KeyError: 'Alice'
Updating Dictionary:
You can update a dictionary by adding a new entry or item (i.e., a key-value pair), modifying an existing entry, or deleting an existing entry as shown below in the simple example:

#!/usr/bin/python

dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'};

dict['Age'] = 8; # update existing entry
dict['School'] = "DPS School"; # Add new entry


print "dict['Age']: ", dict['Age'];
print "dict['School']: ", dict['School'];
When the above code is executed, it produces the following result:

dict['Age']:  8
dict['School']:  DPS School
Delete Dictionary Elements:
You can either remove individual dictionary elements or clear the entire contents of a dictionary. You can also delete entire dictionary in a single operation.

To explicitly remove an entire dictionary, just use the del statement. Following is a simple example:

#!/usr/bin/python

dict = {'Name': 'Zara', 'Age': 7, 'Class': 'First'};

del dict['Name']; # remove entry with key 'Name'
dict.clear();     # remove all entries in dict
del dict ;        # delete entire dictionary

print "dict['Age']: ", dict['Age'];
print "dict['School']: ", dict['School'];
This will produce the following result. Note an exception raised, this is because after del dict dictionary does not exist any more:

dict['Age']:
Traceback (most recent call last):
  File "test.py", line 8, in <module>
    print "dict['Age']: ", dict['Age'];
TypeError: 'type' object is unsubscriptable
Note: del() method is discussed in subsequent section.

Properties of Dictionary Keys:
Dictionary values have no restrictions. They can be any arbitrary Python object, either standard objects or user-defined objects. However, same is not true for the keys.

There are two important points to remember about dictionary keys:

(a) More than one entry per key not allowed. Which means no duplicate key is allowed. When duplicate keys encountered during assignment, the last assignment wins. Following is a simple example:

#!/usr/bin/python

dict = {'Name': 'Zara', 'Age': 7, 'Name': 'Manni'};

print "dict['Name']: ", dict['Name'];
When the above code is executed, it produces the following result:

dict['Name']:  Manni
(b) Keys must be immutable. Which means you can use strings, numbers or tuples as dictionary keys but something like ['key'] is not allowed. Following is a simple example:

#!/usr/bin/python

dict = {['Name']: 'Zara', 'Age': 7};

print "dict['Name']: ", dict['Name'];
When the above code is executed, it produces the following result:

Traceback (most recent call last):
  File "test.py", line 3, in <module>
    dict = {['Name']: 'Zara', 'Age': 7};
TypeError: list objects are unhashable
Built-in Dictionary Functions & Methods:
Python includes the following dictionary functions:

SN	Function with Description
1	cmp(dict1, dict2)
Compares elements of both dict.
2	len(dict)
Gives the total length of the dictionary. This would be equal to the number of items in the dictionary.
3	str(dict)
Produces a printable string representation of a dictionary
4	type(variable)
Returns the type of the passed variable. If passed variable is dictionary, then it would return a dictionary type.
Python includes following dictionary methods

SN	Methods with Description
1	dict.clear()
Removes all elements of dictionary dict
2	dict.copy()
Returns a shallow copy of dictionary dict
3	dict.fromkeys()
Create a new dictionary with keys from seq and values set to value.
4	dict.get(key, default=None)
For key key, returns value or default if key not in dictionary
5	dict.has_key(key)
Returns true if key in dictionary dict, false otherwise
6	dict.items()
Returns a list of dict's (key, value) tuple pairs
7	dict.keys()
Returns list of dictionary dict's keys
8	dict.setdefault(key, default=None)
Similar to get(), but will set dict[key]=default if key is not already in dict
9	dict.update(dict2)
Adds dictionary dict2's key-values pairs to dict
10	dict.values()
Returns list of dictionary dict's values








<h1>Creating Identifiers</h1>
<body>

Creating Identifiers or <strong style="color:blue">variables</strong> in python is quite an easy task.
Simply assign whichever value you want to any name you want to call it.<br>
Really, that's it.<br>
<code style="color:blue">Name_of_variable</code> = <strong>value</strong>
This is what happens behind the scenes:<br>
When you assign a name to a value,  Python allocates a memory or a space and then places a value inside that space giving it the name you gave it.<br>
So when you say:<br>
<code style="color:blue">score</code> = <strong>125</strong><br>
Python looks for a container and puts <strong>125</strong> in it and then names or labels the container score.
Creating variables in Python is quite interesting, this is because you do not need to specify to Python the data type of the value as is the custom in other languages, Python intelligently guesses the data type by looking at the value provided.
This is what I'm saying, in other languages,  you have to specify the data type say:<br>
Integer/String/Float <code style="color:blue">variable_name</code>
And then you can assign the value to it, yes, all of it could be done on the same line but you can testify that Python is smarter here.

<h4>Let us create some variables and see if Python identifies their data types automatically.</h4>

<ul>
    <li><code style="color:blue;font-weight:bold">Name</code> = <strong>"Kojo"</strong></li>
    <li><code style="color:blue;font-weight:bold">Score</code> = <strong>145</strong></li>
    <li><code style="color:blue;font-weight:bold">Height</code> = <strong>36.5</strong></li>
    <li><code style="color:blue;font-weight:bold">Months</code> = <strong>['Jan','Feb', 'March']</strong></li>
    <li><code style="color:blue;font-weight:bold">Info</code> = <strong>{'Name':'Hazard','Team':'Chelsea','Age'"23}</strong></li>
    <li><code style="color:blue;font-weight:bold">Items_to_print</code> = <strong>(Name, Height, Months, Info, Score)</strong></li>
</ul>

Now, in Python, to check out the data type of a particular value, simply input this:

<code style="color:blue">print</code> (type(value))
So apply this by putting each of our variable names in place of  'value', Python should be able to correctly tell you
all the data types of these variables that we have created.

Equally, names are given to functions/methods, classes which are data types that
we can create for ourselves.
You wool better understand this naming when we get to functions and classes.

<h3>Variable Naming Rules</h3>

We just saw how easy it is to create variables but if
you watched closely they seem to follow certain rules.
Take a look at how we created the last variable:
<code style="color:blue;font-size:bold">items_to_print</code>
Do you think I used the underscores for fun or you are guessing it's
one of the rules?
You guessed right, you can't use spaces in variable naming
So here are the rules, no one will beat you for not obeying
them, but Python will not understand you
and will throw you errors if you don't follow them.

<ol>
<li> Special characters are not allowed in naming variables. Yeah,  but the underscore
    is allowed, a cheat?</li>
    <li>Punctuation marks are not allowed in it.</li>
    <li> Operations are not allowed since Python might try computing things for seeing operations.</li>
<li>Identifiers can be a combination of letters in lowercase (a to z) or uppercase (A to Z) or digits (0 to 9) or an underscore (_).
    Names like <strong style="color:blue">myClass</strong>,<strong style="color:blue">var_1</strong> and
    <code style="color:blue"> print_this_to_screen</code>, all are valid examples.</li>
<li>An identifier cannot start with a digit - <strong style="color:red">1variable</strong> is invalid,
    but <strong style="color:blue">variable1</strong> perfectly fine.</li>
    <li>You <strong style="color:red">cannot</strong> give a variable name that Python has reserved for itself for your own.</li>
</ol>

Yeah, of course, you need to know these reserved Keywords.


<h2>Python's Reserved Keywords</h2>

<table>


<tr>
    <td>False</td>
    <td>class</td>
    <td>finally</td>
    <td>is</td>
    <td>return</td>
    <td>None</td>
</tr>
<tr>
    <td>continue</td>
    <td>for</td>
    <td>lambda</td>
    <td>try</td>
    <td>True</td>
    <td>def</td>
</tr>
    <td>from</td>
    <td>non</td>
    <td>local</td>
    <td>while</td>
    <td>and</td>
    <td>del</td>
</tr>
<tr>
    <td>global</td>
    <td>not</td>
    <td>with</td>
    <td>as</td>
    <td>elif</td>
    <td>if</td>
</tr>
<tr>
    <td>or</td>
    <td>yield</td>
    <td>assert</td>
    <td>else</td>
    <td>import</td>
    <td>pass</td>
</tr>
<tr>
<td>break</td>
<td>except</td>
<td>in</td>
<td>raise</td>
</tr>
</table>

<p style="color:purple"><strong>These are words that have been predefined for the language,
which means Python has a certain meaning attached to these names
    already, so using these names will be confusing Python so it is not allowed.</strong></p>


</body>
